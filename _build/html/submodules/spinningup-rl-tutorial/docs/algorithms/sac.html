
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>Soft Actor-Critic &#8212; multi-agent-market-rl 26.7.21 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/alabaster.css" />
    <script data-url_root="../../../../" id="documentation_options" src="../../../../_static/documentation_options.js"></script>
    <script src="../../../../_static/jquery.js"></script>
    <script src="../../../../_static/underscore.js"></script>
    <script src="../../../../_static/doctools.js"></script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" />
   
  <link rel="stylesheet" href="../../../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="soft-actor-critic">
<h1><a class="toc-backref" href="#id2">Soft Actor-Critic</a><a class="headerlink" href="#soft-actor-critic" title="Permalink to this headline">¶</a></h1>
<div class="contents topic" id="table-of-contents">
<p class="topic-title">Table of Contents</p>
<ul class="simple">
<li><p><a class="reference internal" href="#soft-actor-critic" id="id2">Soft Actor-Critic</a></p>
<ul>
<li><p><a class="reference internal" href="#background" id="id3">Background</a></p>
<ul>
<li><p><a class="reference internal" href="#quick-facts" id="id4">Quick Facts</a></p></li>
<li><p><a class="reference internal" href="#key-equations" id="id5">Key Equations</a></p>
<ul>
<li><p><a class="reference internal" href="#entropy-regularized-reinforcement-learning" id="id6">Entropy-Regularized Reinforcement Learning</a></p></li>
<li><p><a class="reference internal" href="#id1" id="id7">Soft Actor-Critic</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#exploration-vs-exploitation" id="id8">Exploration vs. Exploitation</a></p></li>
<li><p><a class="reference internal" href="#pseudocode" id="id9">Pseudocode</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#documentation" id="id10">Documentation</a></p>
<ul>
<li><p><a class="reference internal" href="#documentation-pytorch-version" id="id11">Documentation: PyTorch Version</a></p></li>
<li><p><a class="reference internal" href="#saved-model-contents-pytorch-version" id="id12">Saved Model Contents: PyTorch Version</a></p></li>
<li><p><a class="reference internal" href="#documentation-tensorflow-version" id="id13">Documentation: Tensorflow Version</a></p></li>
<li><p><a class="reference internal" href="#saved-model-contents-tensorflow-version" id="id14">Saved Model Contents: Tensorflow Version</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#references" id="id15">References</a></p>
<ul>
<li><p><a class="reference internal" href="#relevant-papers" id="id16">Relevant Papers</a></p></li>
<li><p><a class="reference internal" href="#other-public-implementations" id="id17">Other Public Implementations</a></p></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<section id="background">
<h2><a class="toc-backref" href="#id3">Background</a><a class="headerlink" href="#background" title="Permalink to this headline">¶</a></h2>
<p>(Previously: <a class="reference external" href="../algorithms/td3.html#background">Background for TD3</a>)</p>
<p>Soft Actor Critic (SAC) is an algorithm that optimizes a stochastic policy in an off-policy way, forming a bridge between stochastic policy optimization and DDPG-style approaches. It isn’t a direct successor to TD3 (having been published roughly concurrently), but it incorporates the clipped double-Q trick, and due to the inherent stochasticity of the policy in SAC, it also winds up benefiting from something like target policy smoothing.</p>
<p>A central feature of SAC is <strong>entropy regularization.</strong> The policy is trained to maximize a trade-off between expected return and <a class="reference external" href="https://en.wikipedia.org/wiki/Entropy_(information_theory)">entropy</a>, a measure of randomness in the policy. This has a close connection to the exploration-exploitation trade-off: increasing entropy results in more exploration, which can accelerate learning later on. It can also prevent the policy from prematurely converging to a bad local optimum.</p>
<section id="quick-facts">
<h3><a class="toc-backref" href="#id4">Quick Facts</a><a class="headerlink" href="#quick-facts" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p>SAC is an off-policy algorithm.</p></li>
<li><p>The version of SAC implemented here can only be used for environments with continuous action spaces.</p></li>
<li><p>An alternate version of SAC, which slightly changes the policy update rule, can be implemented to handle discrete action spaces.</p></li>
<li><p>The Spinning Up implementation of SAC does not support parallelization.</p></li>
</ul>
</section>
<section id="key-equations">
<h3><a class="toc-backref" href="#id5">Key Equations</a><a class="headerlink" href="#key-equations" title="Permalink to this headline">¶</a></h3>
<p>To explain Soft Actor Critic, we first have to introduce the entropy-regularized reinforcement learning setting. In entropy-regularized RL, there are slightly-different equations for value functions.</p>
<section id="entropy-regularized-reinforcement-learning">
<h4><a class="toc-backref" href="#id6">Entropy-Regularized Reinforcement Learning</a><a class="headerlink" href="#entropy-regularized-reinforcement-learning" title="Permalink to this headline">¶</a></h4>
<p>Entropy is a quantity which, roughly speaking, says how random a random variable is. If a coin is weighted so that it almost always comes up heads, it has low entropy; if it’s evenly weighted and has a half chance of either outcome, it has high entropy.</p>
<p>Let <span class="math notranslate nohighlight">\(x\)</span> be a random variable with probability mass or density function <span class="math notranslate nohighlight">\(P\)</span>. The entropy <span class="math notranslate nohighlight">\(H\)</span> of <span class="math notranslate nohighlight">\(x\)</span> is computed from its distribution <span class="math notranslate nohighlight">\(P\)</span> according to</p>
<div class="math notranslate nohighlight">
\[H(P) = \underE{x \sim P}{-\log P(x)}.\]</div>
<p>In entropy-regularized reinforcement learning, the agent gets a bonus reward at each time step proportional to the entropy of the policy at that timestep. This changes <a class="reference external" href="../spinningup/rl_intro.html#the-rl-problem">the RL problem</a> to:</p>
<div class="math notranslate nohighlight">
\[\pi^* = \arg \max_{\pi} \underE{\tau \sim \pi}{ \sum_{t=0}^{\infty} \gamma^t \bigg( R(s_t, a_t, s_{t+1}) + \alpha H\left(\pi(\cdot|s_t)\right) \bigg)},\]</div>
<p>where <span class="math notranslate nohighlight">\(\alpha &gt; 0\)</span> is the trade-off coefficient. (Note: we’re assuming an infinite-horizon discounted setting here, and we’ll do the same for the rest of this page.) We can now define the slightly-different value functions in this setting. <span class="math notranslate nohighlight">\(V^{\pi}\)</span> is changed to include the entropy bonuses from every timestep:</p>
<div class="math notranslate nohighlight">
\[V^{\pi}(s) = \underE{\tau \sim \pi}{ \left. \sum_{t=0}^{\infty} \gamma^t \bigg( R(s_t, a_t, s_{t+1}) + \alpha H\left(\pi(\cdot|s_t)\right) \bigg) \right| s_0 = s}\]</div>
<p><span class="math notranslate nohighlight">\(Q^{\pi}\)</span> is changed to include the entropy bonuses from every timestep <em>except the first</em>:</p>
<div class="math notranslate nohighlight">
\[Q^{\pi}(s,a) = \underE{\tau \sim \pi}{ \left. \sum_{t=0}^{\infty} \gamma^t  R(s_t, a_t, s_{t+1}) + \alpha \sum_{t=1}^{\infty} \gamma^t H\left(\pi(\cdot|s_t)\right)\right| s_0 = s, a_0 = a}\]</div>
<p>With these definitions, <span class="math notranslate nohighlight">\(V^{\pi}\)</span> and <span class="math notranslate nohighlight">\(Q^{\pi}\)</span> are connected by:</p>
<div class="math notranslate nohighlight">
\[V^{\pi}(s) = \underE{a \sim \pi}{Q^{\pi}(s,a)} + \alpha H\left(\pi(\cdot|s)\right)\]</div>
<p>and the Bellman equation for <span class="math notranslate nohighlight">\(Q^{\pi}\)</span> is</p>
<div class="math notranslate nohighlight">
\[\begin{split}Q^{\pi}(s,a) &amp;= \underE{s' \sim P \\ a' \sim \pi}{R(s,a,s') + \gamma\left(Q^{\pi}(s',a') + \alpha H\left(\pi(\cdot|s')\right) \right)} \\
&amp;= \underE{s' \sim P}{R(s,a,s') + \gamma V^{\pi}(s')}.\end{split}\]</div>
<div class="admonition-you-should-know admonition">
<p class="admonition-title">You Should Know</p>
<p>The way we’ve set up the value functions in the entropy-regularized setting is a little bit arbitrary, and actually we could have done it differently (eg make <span class="math notranslate nohighlight">\(Q^{\pi}\)</span> include the entropy bonus at the first timestep). The choice of definition may vary slightly across papers on the subject.</p>
</div>
</section>
<section id="id1">
<h4><a class="toc-backref" href="#id7">Soft Actor-Critic</a><a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h4>
<p>SAC concurrently learns a policy <span class="math notranslate nohighlight">\(\pi_{\theta}\)</span> and two Q-functions <span class="math notranslate nohighlight">\(Q_{\phi_1}, Q_{\phi_2}\)</span>. There are two variants of SAC that are currently standard: one that uses a fixed entropy regularization coefficient <span class="math notranslate nohighlight">\(\alpha\)</span>, and another that enforces an entropy constraint by varying <span class="math notranslate nohighlight">\(\alpha\)</span> over the course of training. For simplicity, Spinning Up makes use of the version with a fixed entropy regularization coefficient, but the entropy-constrained variant is generally preferred by practitioners.</p>
<div class="admonition-you-should-know admonition">
<p class="admonition-title">You Should Know</p>
<p>The SAC algorithm has changed a little bit over time. An older version of SAC also learns a value function <span class="math notranslate nohighlight">\(V_{\psi}\)</span> in addition to the Q-functions; this page will focus on the modern version that omits the extra value function.</p>
</div>
<p><strong>Learning Q.</strong> The Q-functions are learned in a similar way to TD3, but with a few key differences.</p>
<p>First, what’s similar?</p>
<ol class="arabic simple">
<li><p>Like in TD3, both Q-functions are learned with MSBE minimization, by regressing to a single shared target.</p></li>
<li><p>Like in TD3, the shared target is computed using target Q-networks, and the target Q-networks are obtained by polyak averaging the Q-network parameters over the course of training.</p></li>
<li><p>Like in TD3, the shared target makes use of the <strong>clipped double-Q</strong> trick.</p></li>
</ol>
<p>What’s different?</p>
<ol class="arabic simple">
<li><p>Unlike in TD3, the target also includes a term that comes from SAC’s use of entropy regularization.</p></li>
<li><p>Unlike in TD3, the next-state actions used in the target come from the <strong>current policy</strong> instead of a target policy.</p></li>
<li><p>Unlike in TD3, there is no explicit target policy smoothing. TD3 trains a deterministic policy, and so it accomplishes smoothing by adding random noise to the next-state actions. SAC trains a stochastic policy, and so the noise from that stochasticity is sufficient to get a similar effect.</p></li>
</ol>
<p>Before we give the final form of the Q-loss, let’s take a moment to discuss how the contribution from entropy regularization comes in. We’ll start by taking our recursive Bellman equation for the entropy-regularized <span class="math notranslate nohighlight">\(Q^{\pi}\)</span> from earlier, and rewriting it a little bit by using the definition of entropy:</p>
<div class="math notranslate nohighlight">
\[\begin{split}Q^{\pi}(s,a) &amp;= \underE{s' \sim P \\ a' \sim \pi}{R(s,a,s') + \gamma\left(Q^{\pi}(s',a') + \alpha H\left(\pi(\cdot|s')\right) \right)} \\
&amp;= \underE{s' \sim P \\ a' \sim \pi}{R(s,a,s') + \gamma\left(Q^{\pi}(s',a') - \alpha \log \pi(a'|s') \right)}\end{split}\]</div>
<p>The RHS is an expectation over next states (which come from the replay buffer) and next actions (which come from the current policy, and <strong>not</strong> the replay buffer). Since it’s an expectation, we can approximate it with samples:</p>
<div class="math notranslate nohighlight">
\[Q^{\pi}(s,a) &amp;\approx r + \gamma\left(Q^{\pi}(s',\tilde{a}') - \alpha \log \pi(\tilde{a}'|s') \right), \;\;\;\;\;  \tilde{a}' \sim \pi(\cdot|s').\]</div>
<div class="admonition-you-should-know admonition">
<p class="admonition-title">You Should Know</p>
<p>We switch next action notation to <span class="math notranslate nohighlight">\(\tilde{a}'\)</span>, instead of <span class="math notranslate nohighlight">\(a'\)</span>, to highlight that the next actions have to be sampled fresh from the policy (whereas by contrast, <span class="math notranslate nohighlight">\(r\)</span> and <span class="math notranslate nohighlight">\(s'\)</span> should come from the replay buffer).</p>
</div>
<p>SAC sets up the MSBE loss for each Q-function using this kind of sample approximation for the target. The only thing still undetermined here is which Q-function gets used to compute the sample backup: like TD3, SAC uses the clipped double-Q trick, and takes the minimum Q-value between the two Q approximators.</p>
<p>Putting it all together, the loss functions for the Q-networks in SAC are:</p>
<div class="math notranslate nohighlight">
\[L(\phi_i, {\mathcal D}) = \underset{(s,a,r,s',d) \sim {\mathcal D}}{{\mathrm E}}\left[
    \Bigg( Q_{\phi_i}(s,a) - y(r,s',d) \Bigg)^2
    \right],\]</div>
<p>where the target is given by</p>
<div class="math notranslate nohighlight">
\[y(r, s', d) = r + \gamma (1 - d) \left( \min_{j=1,2} Q_{\phi_{\text{targ},j}}(s', \tilde{a}') - \alpha \log \pi_{\theta}(\tilde{a}'|s') \right), \;\;\;\;\; \tilde{a}' \sim \pi_{\theta}(\cdot|s').\]</div>
<p><strong>Learning the Policy.</strong> The policy should, in each state, act to maximize the expected future return plus expected future entropy. That is, it should maximize <span class="math notranslate nohighlight">\(V^{\pi}(s)\)</span>, which we expand out into</p>
<div class="math notranslate nohighlight">
\[\begin{split}V^{\pi}(s) &amp;= \underE{a \sim \pi}{Q^{\pi}(s,a)} + \alpha H\left(\pi(\cdot|s)\right) \\
&amp;= \underE{a \sim \pi}{Q^{\pi}(s,a) - \alpha \log \pi(a|s)}.\end{split}\]</div>
<p>The way we optimize the policy makes use of the <strong>reparameterization trick</strong>, in which a sample from <span class="math notranslate nohighlight">\(\pi_{\theta}(\cdot|s)\)</span> is drawn by computing a deterministic function of state, policy parameters, and independent noise. To illustrate: following the authors of the SAC paper, we use a squashed Gaussian policy, which means that samples are obtained according to</p>
<div class="math notranslate nohighlight">
\[\tilde{a}_{\theta}(s, \xi) = \tanh\left( \mu_{\theta}(s) + \sigma_{\theta}(s) \odot \xi \right), \;\;\;\;\; \xi \sim \mathcal{N}(0, I).\]</div>
<div class="admonition-you-should-know admonition">
<p class="admonition-title">You Should Know</p>
<p>This policy has two key differences from the policies we use in the other policy optimization algorithms:</p>
<p><strong>1. The squashing function.</strong> The <span class="math notranslate nohighlight">\(\tanh\)</span> in the SAC policy ensures that actions are bounded to a finite range. This is absent in the VPG, TRPO, and PPO policies. It also changes the distribution: before the <span class="math notranslate nohighlight">\(\tanh\)</span> the SAC policy is a factored Gaussian like the other algorithms’ policies, but after the <span class="math notranslate nohighlight">\(\tanh\)</span> it is not. (You can still compute the log-probabilities of actions in closed form, though: see the paper appendix for details.)</p>
<p><strong>2. The way standard deviations are parameterized.</strong> In VPG, TRPO, and PPO, we represent the log std devs with state-independent parameter vectors. In SAC, we represent the log std devs as outputs from the neural network, meaning that they depend on state in a complex way. SAC with state-independent log std devs, in our experience, did not work. (Can you think of why? Or better yet: run an experiment to verify?)</p>
</div>
<p>The reparameterization trick allows us to rewrite the expectation over actions (which contains a pain point: the distribution depends on the policy parameters) into an expectation over noise (which removes the pain point: the distribution now has no dependence on parameters):</p>
<div class="math notranslate nohighlight">
\[\underE{a \sim \pi_{\theta}}{Q^{\pi_{\theta}}(s,a) - \alpha \log \pi_{\theta}(a|s)} = \underE{\xi \sim \mathcal{N}}{Q^{\pi_{\theta}}(s,\tilde{a}_{\theta}(s,\xi)) - \alpha \log \pi_{\theta}(\tilde{a}_{\theta}(s,\xi)|s)}\]</div>
<p>To get the policy loss, the final step is that we need to substitute <span class="math notranslate nohighlight">\(Q^{\pi_{\theta}}\)</span> with one of our function approximators. Unlike in TD3, which uses <span class="math notranslate nohighlight">\(Q_{\phi_1}\)</span> (just the first Q approximator), SAC uses <span class="math notranslate nohighlight">\(\min_{j=1,2} Q_{\phi_j}\)</span> (the minimum of the two Q approximators). The policy is thus optimized according to</p>
<div class="math notranslate nohighlight">
\[\begin{split}\max_{\theta} \underE{s \sim \mathcal{D} \\ \xi \sim \mathcal{N}}{\min_{j=1,2} Q_{\phi_j}(s,\tilde{a}_{\theta}(s,\xi)) - \alpha \log \pi_{\theta}(\tilde{a}_{\theta}(s,\xi)|s)},\end{split}\]</div>
<p>which is almost the same as the DDPG and TD3 policy optimization, except for the min-double-Q trick, the stochasticity, and the entropy term.</p>
</section>
</section>
<section id="exploration-vs-exploitation">
<h3><a class="toc-backref" href="#id8">Exploration vs. Exploitation</a><a class="headerlink" href="#exploration-vs-exploitation" title="Permalink to this headline">¶</a></h3>
<p>SAC trains a stochastic policy with entropy regularization, and explores in an on-policy way. The entropy regularization coefficient <span class="math notranslate nohighlight">\(\alpha\)</span> explicitly controls the explore-exploit tradeoff, with higher <span class="math notranslate nohighlight">\(\alpha\)</span> corresponding to more exploration, and lower <span class="math notranslate nohighlight">\(\alpha\)</span> corresponding to more exploitation. The right coefficient (the one which leads to the stablest / highest-reward learning) may vary from environment to environment, and could require careful tuning.</p>
<p>At test time, to see how well the policy exploits what it has learned, we remove stochasticity and use the mean action instead of a sample from the distribution. This tends to improve performance over the original stochastic policy.</p>
<div class="admonition-you-should-know admonition">
<p class="admonition-title">You Should Know</p>
<p>Our SAC implementation uses a trick to improve exploration at the start of training. For a fixed number of steps at the beginning (set with the <code class="docutils literal notranslate"><span class="pre">start_steps</span></code> keyword argument), the agent takes actions which are sampled from a uniform random distribution over valid actions. After that, it returns to normal SAC exploration.</p>
</div>
</section>
<section id="pseudocode">
<h3><a class="toc-backref" href="#id9">Pseudocode</a><a class="headerlink" href="#pseudocode" title="Permalink to this headline">¶</a></h3>
<div class="math notranslate nohighlight">
\begin{algorithm}[H]
    \caption{Soft Actor-Critic}
    \label{alg1}
\begin{algorithmic}[1]
    \STATE Input: initial policy parameters $\theta$, Q-function parameters $\phi_1$, $\phi_2$, empty replay buffer $\mathcal{D}$
    \STATE Set target parameters equal to main parameters $\phi_{\text{targ},1} \leftarrow \phi_1$, $\phi_{\text{targ},2} \leftarrow \phi_2$
    \REPEAT
        \STATE Observe state $s$ and select action $a \sim \pi_{\theta}(\cdot|s)$
        \STATE Execute $a$ in the environment
        \STATE Observe next state $s'$, reward $r$, and done signal $d$ to indicate whether $s'$ is terminal
        \STATE Store $(s,a,r,s',d)$ in replay buffer $\mathcal{D}$
        \STATE If $s'$ is terminal, reset environment state.
        \IF{it's time to update}
            \FOR{$j$ in range(however many updates)}
                \STATE Randomly sample a batch of transitions, $B = \{ (s,a,r,s',d) \}$ from $\mathcal{D}$
                \STATE Compute targets for the Q functions:
                \begin{align*}
                    y (r,s',d) &amp;= r + \gamma (1-d) \left(\min_{i=1,2} Q_{\phi_{\text{targ}, i}} (s', \tilde{a}') - \alpha \log \pi_{\theta}(\tilde{a}'|s')\right), &amp;&amp; \tilde{a}' \sim \pi_{\theta}(\cdot|s')
                \end{align*}
                \STATE Update Q-functions by one step of gradient descent using
                \begin{align*}
                    &amp; \nabla_{\phi_i} \frac{1}{|B|}\sum_{(s,a,r,s',d) \in B} \left( Q_{\phi_i}(s,a) - y(r,s',d) \right)^2 &amp;&amp; \text{for } i=1,2
                \end{align*}
                \STATE Update policy by one step of gradient ascent using
                \begin{equation*}
                    \nabla_{\theta} \frac{1}{|B|}\sum_{s \in B} \Big(\min_{i=1,2} Q_{\phi_i}(s, \tilde{a}_{\theta}(s)) - \alpha \log \pi_{\theta} \left(\left. \tilde{a}_{\theta}(s) \right| s\right) \Big),
                \end{equation*}
                where $\tilde{a}_{\theta}(s)$ is a sample from $\pi_{\theta}(\cdot|s)$ which is differentiable wrt $\theta$ via the reparametrization trick.
                \STATE Update target networks with
                \begin{align*}
                    \phi_{\text{targ},i} &amp;\leftarrow \rho \phi_{\text{targ}, i} + (1-\rho) \phi_i &amp;&amp; \text{for } i=1,2
                \end{align*}
            \ENDFOR
        \ENDIF
    \UNTIL{convergence}
\end{algorithmic}
\end{algorithm}</div></section>
</section>
<section id="documentation">
<h2><a class="toc-backref" href="#id10">Documentation</a><a class="headerlink" href="#documentation" title="Permalink to this headline">¶</a></h2>
<div class="admonition-you-should-know admonition">
<p class="admonition-title">You Should Know</p>
<p>In what follows, we give documentation for the PyTorch and Tensorflow implementations of SAC in Spinning Up. They have nearly identical function calls and docstrings, except for details relating to model construction. However, we include both full docstrings for completeness.</p>
</div>
<section id="documentation-pytorch-version">
<h3><a class="toc-backref" href="#id11">Documentation: PyTorch Version</a><a class="headerlink" href="#documentation-pytorch-version" title="Permalink to this headline">¶</a></h3>
</section>
<section id="saved-model-contents-pytorch-version">
<h3><a class="toc-backref" href="#id12">Saved Model Contents: PyTorch Version</a><a class="headerlink" href="#saved-model-contents-pytorch-version" title="Permalink to this headline">¶</a></h3>
<p>The PyTorch saved model can be loaded with <code class="docutils literal notranslate"><span class="pre">ac</span> <span class="pre">=</span> <span class="pre">torch.load('path/to/model.pt')</span></code>, yielding an actor-critic object (<code class="docutils literal notranslate"><span class="pre">ac</span></code>) that has the properties described in the docstring for <code class="docutils literal notranslate"><span class="pre">sac_pytorch</span></code>.</p>
<p>You can get actions from this model with</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">actions</span> <span class="o">=</span> <span class="n">ac</span><span class="o">.</span><span class="n">act</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">as_tensor</span><span class="p">(</span><span class="n">obs</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">float32</span><span class="p">))</span>
</pre></div>
</div>
</section>
<section id="documentation-tensorflow-version">
<h3><a class="toc-backref" href="#id13">Documentation: Tensorflow Version</a><a class="headerlink" href="#documentation-tensorflow-version" title="Permalink to this headline">¶</a></h3>
</section>
<section id="saved-model-contents-tensorflow-version">
<h3><a class="toc-backref" href="#id14">Saved Model Contents: Tensorflow Version</a><a class="headerlink" href="#saved-model-contents-tensorflow-version" title="Permalink to this headline">¶</a></h3>
<p>The computation graph saved by the logger includes:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 9%" />
<col style="width: 91%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Key</p></th>
<th class="head"><p>Value</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">x</span></code></p></td>
<td><p>Tensorflow placeholder for state input.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">a</span></code></p></td>
<td><p>Tensorflow placeholder for action input.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">mu</span></code></p></td>
<td><p>Deterministically computes mean action from the agent, given states in <code class="docutils literal notranslate"><span class="pre">x</span></code>.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">pi</span></code></p></td>
<td><p>Samples an action from the agent, conditioned on states in <code class="docutils literal notranslate"><span class="pre">x</span></code>.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">q1</span></code></p></td>
<td><p>Gives one action-value estimate for states in <code class="docutils literal notranslate"><span class="pre">x</span></code> and actions in <code class="docutils literal notranslate"><span class="pre">a</span></code>.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">q2</span></code></p></td>
<td><p>Gives the other action-value estimate for states in <code class="docutils literal notranslate"><span class="pre">x</span></code> and actions in <code class="docutils literal notranslate"><span class="pre">a</span></code>.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">v</span></code></p></td>
<td><p>Gives the value estimate for states in <code class="docutils literal notranslate"><span class="pre">x</span></code>.</p></td>
</tr>
</tbody>
</table>
<p>This saved model can be accessed either by</p>
<ul class="simple">
<li><p>running the trained policy with the <a class="reference external" href="../user/saving_and_loading.html#loading-and-running-trained-policies">test_policy.py</a> tool,</p></li>
<li><p>or loading the whole saved graph into a program with <a class="reference external" href="../utils/logger.html#spinup.utils.logx.restore_tf_graph">restore_tf_graph</a>.</p></li>
</ul>
<p>Note: for SAC, the correct evaluation policy is given by <code class="docutils literal notranslate"><span class="pre">mu</span></code> and not by <code class="docutils literal notranslate"><span class="pre">pi</span></code>. The policy <code class="docutils literal notranslate"><span class="pre">pi</span></code> may be thought of as the exploration policy, while <code class="docutils literal notranslate"><span class="pre">mu</span></code> is the exploitation policy.</p>
</section>
</section>
<section id="references">
<h2><a class="toc-backref" href="#id15">References</a><a class="headerlink" href="#references" title="Permalink to this headline">¶</a></h2>
<section id="relevant-papers">
<h3><a class="toc-backref" href="#id16">Relevant Papers</a><a class="headerlink" href="#relevant-papers" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p><a class="reference external" href="https://arxiv.org/abs/1801.01290">Soft Actor-Critic: Off-Policy Maximum Entropy Deep Reinforcement Learning with a Stochastic Actor</a>, Haarnoja et al, 2018</p></li>
<li><p><a class="reference external" href="https://arxiv.org/abs/1812.05905">Soft Actor-Critic Algorithms and Applications</a>, Haarnoja et al, 2018</p></li>
<li><p><a class="reference external" href="https://arxiv.org/abs/1812.11103">Learning to Walk via Deep Reinforcement Learning</a>, Haarnoja et al, 2018</p></li>
</ul>
</section>
<section id="other-public-implementations">
<h3><a class="toc-backref" href="#id17">Other Public Implementations</a><a class="headerlink" href="#other-public-implementations" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p><a class="reference external" href="https://github.com/haarnoja/sac">SAC release repo</a> (original “official” codebase)</p></li>
<li><p><a class="reference external" href="https://github.com/rail-berkeley/softlearning">Softlearning repo</a> (current “official” codebase)</p></li>
<li><p><a class="reference external" href="https://github.com/denisyarats/pytorch_sac">Yarats and Kostrikov repo</a></p></li>
</ul>
</section>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../../../index.html">multi-agent-market-rl</a></h1>








<h3>Navigation</h3>
<p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../MultiAgentMarketRL.html">Multi-Agent-Market-RL</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../../index.html">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2021, Benjamin Suter.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 4.1.1</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../../../../_sources/submodules/spinningup-rl-tutorial/docs/algorithms/sac.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>